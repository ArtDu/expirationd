<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>expirationd API reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">





<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Task_methods">Task methods </a></li>
<li><a href="#Module_methods">Module methods </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>expirationd</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>expirationd</code></h1>
<p>expirationd module</p>
<p><table class="markdown_table">
</table>
</p>


<h2><a href="#Task_methods">Task methods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#task.start">task.start (self)</a></td>
	<td class="summary">Start a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#task.stop">task.stop (self)</a></td>
	<td class="summary">Stop a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#task.restart">task.restart (self)</a></td>
	<td class="summary">Restart a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#task.kill">task.kill (self)</a></td>
	<td class="summary">Kill a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#task.statistics">task.statistics (self)</a></td>
	<td class="summary">Get a statistics about a task.</td>
	</tr>
</table>
<h2><a href="#Module_methods">Module methods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#start">start (name, space_id, is_tuple_expired[, options])</a></td>
	<td class="summary">Run a scheduled task to check and process (expire) tuples in a given space.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#kill">kill (name)</a></td>
	<td class="summary">Kill an existing task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tasks">tasks ()</a></td>
	<td class="summary">Return a copy of task list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#stats">stats ([name])</a></td>
	<td class="summary">Return task statistics in table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#task">task (name)</a></td>
	<td class="summary">Get task by name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#update">update ()</a></td>
	<td class="summary">Reload module.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Task_methods"></a>Task methods </h2>

    <dl class="function Methods">
    <dt>
    <a name="task.start"></a>
    <strong>task.start (self)</strong>
    </dt>
    <dd>
    <p>Start a task. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
        <br>
        <span class="parameter-description">
        <p>
     Task instance.
<p> Force start <code>task</code> (old <code>guardian_fiber</code> will be garbage
 collected, so do <code>task:stop()</code> before or <code>task:restart()</code> instead).
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
    <dt>
    <a name="task.stop"></a>
    <strong>task.stop (self)</strong>
    </dt>
    <dd>
    <p>Stop a task. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
        <br>
        <span class="parameter-description">
        <p>
     Task instance.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
    <dt>
    <a name="task.restart"></a>
    <strong>task.restart (self)</strong>
    </dt>
    <dd>
    <p>Restart a task. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
        <br>
        <span class="parameter-description">
        <p>
     Task instance.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
    <dt>
    <a name="task.kill"></a>
    <strong>task.kill (self)</strong>
    </dt>
    <dd>
    <p>Kill a task. <table class="markdown_table">
</table>
<p>
 Stop a task and delete it from list of tasks.
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
        <br>
        <span class="parameter-description">
        <p>
     Task instance.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
    <dt>
    <a name="task.statistics"></a>
    <strong>task.statistics (self)</strong>
    </dt>
    <dd>
    <p>Get a statistics about a task. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
        <br>
        <span class="parameter-description">
        <p>
     Task instance.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         Response of the following structure:
<p><pre> {
     checked_count = number,
     expired_count = number,
     restarts = number,
     working_time = number,
 }</pre>
<p>
 where:
<p> <code>checked_count</code> is a number of tuples checked for expiration (expired + skipped).
<p> <code>expired_count</code> is a number of expired tuples.
<p> <code>restarts</code> is a number of restarts since start. From the start <code>restarts</code> is equal to 1.
<p> <code>working_time</code> is a task's operation time.

    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Module_methods"></a>Module methods </h2>

    <dl class="function Functions">
    <dt>
    <a name="start"></a>
    <strong>start (name, space_id, is_tuple_expired[, options])</strong>
    </dt>
    <dd>
    <p>Run a scheduled task to check and process (expire) tuples in a given space. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>)
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Task name.</p>
        </span>
        </li>
        <li><span class="parameter">space_id</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>)
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Space to look in for expired tuples.</p>
        </span>
        </li>
        <li><span class="parameter">is_tuple_expired</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>)
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function, must accept tuple and return true/false (is tuple expired or
     not), receives <code>args</code>, <code>tuple</code> as arguments.</p>
        </span>
        </li>
        <li><span class="parameter">options</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">table</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>

        <br>
        <span class="parameter-description">
        <p>
     Table with named options.</p>
        </span>
        <ul>
        <li><span class="parameter">args</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">table</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Passed to <code>is_tuple_expired()</code> and <code>process_expired_tuple()</code> as
     an additional context.</p>
        </span>
        </li>
        <li><span class="parameter">atomic_iteration</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">boolean</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     False (default) to process each tuple as a single transaction and true
     to process tuples from each batch in a single transaction.</p>
        </span>
        </li>
        <li><span class="parameter">force</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">boolean</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     expirationd doesn't work on replica by default. With option <code>force</code> it
     should be possible to force work on replica.</p>
        </span>
        </li>
        <li><span class="parameter">full_scan_delay</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Sleep time between full scans (in seconds). It is allowed to pass an FFI
     number: <code>1LL</code>, <code>1UL</code> etc. Default value is 1 sec.</p>
        </span>
        </li>
        <li><span class="parameter">full_scan_time</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Time required for a full index scan (in seconds). It is allowed to pass
     an FFI number: 1LL, 1UL etc. Default value is 3600.</p>
        </span>
        </li>
        <li><span class="parameter">index</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Name or id of the index to iterate on. If omitted, will use the primary
     index. If there's no index with this name, will throw an error.
     Supported index types are TREE and HASH, using other types will result
     in an error.</p>
        </span>
        </li>
        <li><span class="parameter">iterate_with</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function which returns an iterator object which provides tuples to
     check, considering the <code>start_key</code>, <code>process_while</code> and other options.
     There's a default function which can be overriden with this parameter.</p>
        </span>
        </li>
        <li><span class="parameter">iteration_delay</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Max sleep time between iterations (in seconds). It is allowed to pass
     an FFI number: <code>1LL</code>, <code>1UL</code> etc. Default value is 1 sec.</p>
        </span>
        </li>
        <li><span class="parameter">iterator_type</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Type of the iterator to use, as string or box.index constant, for
     example, 'EQ' or <code>box.index.EQ</code>, default is <code>box.index.ALL</code>. See
     <a href="https://www.tarantool.io/en/doc/latest/reference/reference_lua/box_index/pairs/.">index_object:pairs()</a>.
<p><table class="markdown_table">
</table>
</p>
        </span>
        </li>
        <li><span class="parameter">on_full_scan_complete</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function to call after completing a full scan iteration. Default value
     is a function that do nothing.</p>
        </span>
        </li>
        <li><span class="parameter">on_full_scan_error</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function to call after terminating a full scan due to an error. Default
     value is a function that do nothing.</p>
        </span>
        </li>
        <li><span class="parameter">on_full_scan_start</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function to call before starting a full scan iteration. Default value
     is a function that do nothing.</p>
        </span>
        </li>
        <li><span class="parameter">on_full_scan_success</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function to call after successfully completing a full scan iteration.
     Default value is a function that do nothing.</p>
        </span>
        </li>
        <li><span class="parameter">process_expired_tuple</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Applied to expired tuples, receives <code>space_id</code>, <code>args</code>, <code>tuple</code> as
     arguments. Can be a <code>nil</code>: by default tuples are removed.</p>
        </span>
        </li>
        <li><span class="parameter">process_while</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">func</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Function to call before checking each tuple. If it returns false, the
     task will stop until next full scan.</p>
        </span>
        </li>
        <li><span class="parameter">start_key</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Start iterating from the tuple with this index value. Or when iterator
     is 'EQ', iterate over tuples with this index value. Must be a value of
     the same data type as the index field or fields, or a function which
     returns such value. If omitted or nil, all tuples will be checked.</p>
        </span>
        </li>
        <li><span class="parameter">tuples_per_iteration</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Number of tuples to check in one batch (iteration). It is allowed to
     pass an FFI number: <code>1LL</code>, <code>1UL</code> etc. Default value is 1024.</p>
        </span>
        </li>
        <li><span class="parameter">vinyl_assumed_space_len_factor</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Factor for recalculation of vinyl space size. Vinyl space size can't be
     counted (since many operations, <code>upsert</code> for example, are applied when
     you address some data), so you should count (approximate space size)
     tuples with the first start. <code>vinyl_assumed_space_len</code> is approximate
     count for first run and <code>vinyl_assumed_space_len_factor</code> for next
     milestone (after we've reached next milestone is <code>*</code> and so on). It is
     allowed to pass an FFI number: <code>1LL</code>, <code>1UL</code> etc. Default value is 2.</p>
        </span>
        </li>
        <li><span class="parameter">vinyl_assumed_space_len</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">number</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Assumed size of vinyl space (in the first iteration).
     Vinyl space size can't be counted (since many operations, <code>upsert</code> for
     example, are applied when you address some data), so you should count
     (approximate space size) tuples with the first start.
     <code>vinyl_assumed_space_len</code> is approximate count for first run and
     <code>vinyl_assumed_space_len_factor</code> for next milestone (after we've reached
     next milestone is <code>*</code> and so on). It is allowed to pass an FFI number:
     <code>1LL</code>, <code>1UL</code> etc. Default value is 10^7.
</p>
        </span>
        </li>
        </li></ul>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#task">task</a></span>
        <table class="markdown_table">
</table>

    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> expirationd = <span class="global">require</span>(<span class="string">"expirationd"</span>)

box.cfg{}

<span class="keyword">local</span> space = box.space.old
<span class="keyword">local</span> job_name = <span class="string">"clean_all"</span>

<span class="keyword">local</span> <span class="keyword">function</span> is_expired(args, tuple)
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> delete_tuple(space_id, args, tuple)
    box.space[space_id]:delete{tuple[<span class="number">1</span>]}
<span class="keyword">end</span>

expirationd.start(job_name, space.id, is_expired, {
    process_expired_tuple = delete_tuple,
    args = <span class="keyword">nil</span>,
    tuples_per_iteration = <span class="number">50</span>,
    full_scan_time = <span class="number">3600</span>
})</pre>
    </ul>

</dd>
    <dt>
    <a name="kill"></a>
    <strong>kill (name)</strong>
    </dt>
    <dd>
    <p>Kill an existing task. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>)
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Task name.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
    <dt>
    <a name="tasks"></a>
    <strong>tasks ()</strong>
    </dt>
    <dd>
    <p>Return a copy of task list. <table class="markdown_table">
</table>
</p>



    <h3>Returns:</h3>
    <ol>

         Response of the following structure:
<p><pre> {
     "expirationd-1"
     "expirationd-2",
     "expirationd-3",
 }</pre>
<p>
 Each item in response is a task name.

    </ol>




</dd>
    <dt>
    <a name="stats"></a>
    <strong>stats ([name])</strong>
    </dt>
    <dd>
    <p>Return task statistics in table. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>,
                <span class="parameter-modifier">
                <em>optional</em>)
                </span>
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Task name. If <code>name</code> is nil, then return map of <code>name</code>:<code>stats</code>, else
     return map with stats.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         Response of the following structure:
<p><pre> {
     checked_count = number,
     expired_count = number,
     restarts = number,
     working_time = number,
 }</pre>
<p>
 where:
<p> <code>checked_count</code> is a number of tuples checked for expiration (expired + skipped).
<p> <code>expired_count</code> is a number of expired tuples.
<p> <code>restarts</code> is a number of restarts since start. From the start
 <code>restarts</code> is equal to 1.
<p> <code>working_time</code> is a task's operation time.

    </ol>




</dd>
    <dt>
    <a name="task"></a>
    <strong>task (name)</strong>
    </dt>
    <dd>
    <p>Get task by name. <table class="markdown_table">
</table>
</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="parameter-info">
                (<span class="types"><span class="type">string</span></span>)
            </span>
        <br>
        <span class="parameter-description">
        <p>
     Task name.
</p>
        </span>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         Response of the following structure:
<p><pre> {
     atomic_iteration = false,
     checked_tuples_count = 0,
     do_worker_iteration = function: 0x4180cb68,
     expired_tuples_count = 0,
     full_scan_delay = 1,
     full_scan_time = 3600,
     guardian_fiber = fiber: 122,
     index = {
         hint = true,
         id = 0,
         name = "primary",
         parts = {{fieldno = 1, is_nullable = false, type = "number"}},
         space_id = 512,
         type = "TREE",
         unique = true,
     },
     is_tuple_expired = function: 0x40781db8,
     iterate_with = function: 0x4188ae78,
     iteration_delay = 1,
     iterator_type = "ALL",
     name = "expirationd-2",
     on_full_scan_complete = function: 0x40972568,
     on_full_scan_error = function: 0x40972568,
     on_full_scan_start = function: 0x40972568,
     on_full_scan_success = function: 0x40972568,
     process_expired_tuple = function: 0x4188ae38,
     process_while = function: 0x4148f4c8,
     restarts = 1,
     space_id = 512,
     start_key = function: 0x40994c48,
     start_time = 1631818716.1123,
     tuples_per_iteration = 1024,
     vinyl_assumed_space_len = 10000000,
     vinyl_assumed_space_len_factor = 2,
     worker_cancelled = false,
     worker_fiber = fiber: 123,
 }</pre>
<p>
 where:
<p> <code>atomic_iteration</code> is a boolean value (<span class="xxx">XXX</span>).
<p> <code>checked_tuples_count</code> is a number of processed tuples.
<p> <code>do_worker_iteration</code> is a function (<span class="xxx">XXX</span>).
<p> <code>expired_tuples_count</code> is a number of expired tuples.
<p> <code>full_scan_delay</code> is a number (<span class="xxx">XXX</span>).
<p> <code>full_scan_time</code> is a number (<span class="xxx">XXX</span>).
<p> <code>guardian_fiber</code> is a fiber id (<span class="xxx">XXX</span>).
<p> <code>index</code> is an index used for iteration of tuples.
<p> <code>is_tuple_expired</code> is a function (<span class="xxx">XXX</span>).
<p> <code>iterate_with</code> is a function (<span class="xxx">XXX</span>).
<p> <code>iteration_delay</code> is a number (<span class="xxx">XXX</span>).
<p> <code>iterator_type</code> = "ALL" (<span class="xxx">XXX</span>).
<p> <code>name</code> is a string with name of task.
<p> <code>on_full_scan_complete</code> is a function (<span class="xxx">XXX</span>).
<p> <code>on_full_scan_error</code> is a function (<span class="xxx">XXX</span>).
<p> <code>on_full_scan_start</code> is a function (<span class="xxx">XXX</span>).
<p> <code>on_full_scan_success</code> is a function (<span class="xxx">XXX</span>).
<p> <code>process_expired_tuple</code> is a function (<span class="xxx">XXX</span>).
<p> <code>process_while</code> is a function (<span class="xxx">XXX</span>).
<p> <code>restarts</code> is a number of restarts.
<p> <code>space_id</code> is a space id, where task processes tuples.
<p> <code>start_key</code> is a function (<span class="xxx">XXX</span>).
<p> <code>start_time</code> is a time when task starts.
<p> <code>tuples_per_iteration</code> is a max number of tuples that task can process on
  each iteration.
<p> <code>vinyl_assumed_space_len</code> is a number (<span class="xxx">XXX</span>).
<p> <code>vinyl_assumed_space_len_factor</code> is a number (<span class="xxx">XXX</span>).
<p> <code>worker_cancelled</code> is a boolean value (<span class="xxx">XXX</span>).
<p> <code>worker_fiber</code> is a fiber id.

    </ol>




</dd>
    <dt>
    <a name="update"></a>
    <strong>update ()</strong>
    </dt>
    <dd>
    <p>Reload module. <table class="markdown_table">
</table>
<p>
 Update expirationd version in a running Tarantool and restart all tasks.
 Step by step: remove expirationd module from <code>package.loaded</code>, import new
 version of expirationd using <code>require</code> and finally restart all tasks.
</p>



    <h3>Returns:</h3>
    <ol>

        None
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
</div> <!-- id="container" -->
</body>
</html>
